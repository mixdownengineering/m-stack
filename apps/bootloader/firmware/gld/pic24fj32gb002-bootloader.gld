/************************************************
 Linker script for pic24fj32gb002

 Generated by the Signal 11 Software
 PIC24F Linker Script Generator

 http://github.com/signal11/pic_linker_script

 This script may be used by anyone for any
 purpose and may be redistributed freely.
************************************************/

OUTPUT_ARCH("24FJ32GB002")

CRT0_STARTUP(crt0_standard.o)
CRT1_STARTUP(crt1_standard.o)

/* MCU Properties and Map */
#define CHIP_PROGRAM_START 0x200
#define CHIP_FLASH_TOP_ADDR 0x5800
#define IVT_MAP_SIZE 0x100

#define FLASH_BLOCK_SIZE 0x400

#define IVT_BASE 0x4
#define ALT_IVT_BASE 0x104
#define RESET_BASE 0x0
#define CONFIG1_ADDR 0x57fe
#define CONFIG2_ADDR 0x57fc
#define CONFIG3_ADDR 0x57fa
#define CONFIG4_ADDR 0x57f8

#define CONFIG_WORDS_BASE 0x57f8
#define CONFIG_WORDS_TOP  0x5800

/* Data (RAM) memory */
#define DATA_BASE 0x800
#define DATA_TOP 0x2800

#define BOOTLOADER_SIZE 0x1200

__NO_HANDLES = 1;


#ifdef BOOTLOADER
	#define BOOTLOADER_PROGRAM program
	#define APP_PROGRAM app_program
#elif defined(BOOTLOADER_APP)
	#define BOOTLOADER_PROGRAM bootloader_program
	#define APP_PROGRAM program
#else
	#error "Must define BOOTLOADER or BOOTLOADER_APP to use this linker script"
#endif

#define IVT_MAP_BASE ((CHIP_PROGRAM_START) + (BOOTLOADER_SIZE))
#define APP_BASE ((IVT_MAP_BASE) + (IVT_MAP_SIZE))
#define APP_LENGTH ((CHIP_FLASH_TOP_ADDR) - (FLASH_BLOCK_SIZE) - (APP_BASE))
#define DATA_LENGTH ((DATA_TOP) - (DATA_BASE))

#if IVT_MAP_BASE % FLASH_BLOCK_SIZE != 0
	#error IVT_MAP_BASE is not aligned to a flash block. This may mean that BOOTLOADER_SIZE needs to be adjusted.
#endif

#if CONFIG1_ADDR < CONFIG_WORDS_BASE || CONFIG1_ADDR >= CONFIG_WORDS_TOP
	#error "CONFIG1 out of range"
#endif
#if CONFIG2_ADDR < CONFIG_WORDS_BASE || CONFIG2_ADDR >= CONFIG_WORDS_TOP
	#error "CONFIG2 out of range"
#endif
#if CONFIG3_ADDR < CONFIG_WORDS_BASE || CONFIG3_ADDR >= CONFIG_WORDS_TOP
	#error "CONFIG3 out of range"
#endif
#if CONFIG4_ADDR < CONFIG_WORDS_BASE || CONFIG4_ADDR >= CONFIG_WORDS_TOP
	#error "CONFIG4 out of range"
#endif

MEMORY {
	/* Program Memory Space (Flash) */
#if defined(BOOTLOADER)
	reset : ORIGIN = RESET_BASE, LENGTH = 4
	ivt : ORIGIN = IVT_BASE, LENGTH = 0xfc
	aivt : ORIGIN = ALT_IVT_BASE, LENGTH = 0xfc
#endif
	BOOTLOADER_PROGRAM : ORIGIN = CHIP_PROGRAM_START, LENGTH = BOOTLOADER_SIZE
	ivt_map : ORIGIN = IVT_MAP_BASE, LENGTH = IVT_MAP_SIZE
	APP_PROGRAM : ORIGIN = APP_BASE, LENGTH = APP_LENGTH

	CONFIG1 : ORIGIN = CONFIG1_ADDR, LENGTH = 0x2
	CONFIG2 : ORIGIN = CONFIG2_ADDR, LENGTH = 0x2
	CONFIG3 : ORIGIN = CONFIG3_ADDR, LENGTH = 0x2
	CONFIG4 : ORIGIN = CONFIG4_ADDR, LENGTH = 0x2

	/* Data Space (RAM) */
	data : ORIGIN = DATA_BASE, LENGTH = DATA_LENGTH
};

__DATA_BASE = DATA_BASE;

__CONFIG1 = CONFIG1_ADDR;
__CONFIG2 = CONFIG2_ADDR;
__CONFIG3 = CONFIG3_ADDR;
__CONFIG4 = CONFIG4_ADDR;

/* Values regarding the layout of the flash to pass to the bootloader. 
 * They're under an ifdef only because I can't come up with a use case for
 * an application to use them.  */
#ifdef BOOTLOADER
	__IVT_MAP_BASE = IVT_MAP_BASE;
	__APP_BASE = APP_BASE;
	__APP_LENGTH = APP_LENGTH;
	__FLASH_BLOCK_SIZE = FLASH_BLOCK_SIZE;
	__FLASH_TOP = CHIP_FLASH_TOP_ADDR;
	__CONFIG_WORDS_BASE = CONFIG_WORDS_BASE;
	__CONFIG_WORDS_TOP = CONFIG_WORDS_TOP;
#endif


#ifdef BOOTLOADER
/* Alternate interrupt handlers are not mapped into the application */
#define ALTHANDLER(X) LONG(DEFINED(__Alt##X)? ABSOLUTE(__Alt##X): DEFINED(__##X) ? ABSOLUTE(__##X) : ABSOLUTE(__DefaultInterrupt));
#endif

#define INTERRUPT_LIST() \
		UNUSED_INTERRUPT(ReservedTrap0) \
		INTERRUPT(OscillatorFail) \
		INTERRUPT(AddressError) \
		INTERRUPT(StackError) \
		INTERRUPT(MathError) \
		UNUSED_INTERRUPT(ReservedTrap5) \
		UNUSED_INTERRUPT(ReservedTrap6) \
		UNUSED_INTERRUPT(ReservedTrap7) \
		INTERRUPT(INT0Interrupt) \
		INTERRUPT(IC1Interrupt) \
		INTERRUPT(OC1Interrupt) \
		INTERRUPT(T1Interrupt) \
		UNUSED_INTERRUPT(Interrupt4) \
		INTERRUPT(IC2Interrupt) \
		INTERRUPT(OC2Interrupt) \
		INTERRUPT(T2Interrupt) \
		INTERRUPT(T3Interrupt) \
		INTERRUPT(SPI1ErrInterrupt) \
		INTERRUPT(SPI1Interrupt) \
		INTERRUPT(U1RXInterrupt) \
		INTERRUPT(U1TXInterrupt) \
		INTERRUPT(ADC1Interrupt) \
		UNUSED_INTERRUPT(Interrupt14) \
		UNUSED_INTERRUPT(Interrupt15) \
		INTERRUPT(SI2C1Interrupt) \
		INTERRUPT(MI2C1Interrupt) \
		INTERRUPT(CompInterrupt) \
		INTERRUPT(CNInterrupt) \
		INTERRUPT(INT1Interrupt) \
		UNUSED_INTERRUPT(Interrupt21) \
		UNUSED_INTERRUPT(Interrupt22) \
		UNUSED_INTERRUPT(Interrupt23) \
		UNUSED_INTERRUPT(Interrupt24) \
		INTERRUPT(OC3Interrupt) \
		INTERRUPT(OC4Interrupt) \
		INTERRUPT(T4Interrupt) \
		INTERRUPT(T5Interrupt) \
		INTERRUPT(INT2Interrupt) \
		INTERRUPT(U2RXInterrupt) \
		INTERRUPT(U2TXInterrupt) \
		INTERRUPT(SPI2ErrInterrupt) \
		INTERRUPT(SPI2Interrupt) \
		UNUSED_INTERRUPT(Interrupt34) \
		UNUSED_INTERRUPT(Interrupt35) \
		UNUSED_INTERRUPT(Interrupt36) \
		INTERRUPT(IC3Interrupt) \
		INTERRUPT(IC4Interrupt) \
		INTERRUPT(IC5Interrupt) \
		UNUSED_INTERRUPT(Interrupt40) \
		INTERRUPT(OC5Interrupt) \
		UNUSED_INTERRUPT(Interrupt42) \
		UNUSED_INTERRUPT(Interrupt43) \
		UNUSED_INTERRUPT(Interrupt44) \
		INTERRUPT(PMPInterrupt) \
		UNUSED_INTERRUPT(Interrupt46) \
		UNUSED_INTERRUPT(Interrupt47) \
		UNUSED_INTERRUPT(Interrupt48) \
		INTERRUPT(SI2C2Interrupt) \
		INTERRUPT(MI2C2Interrupt) \
		UNUSED_INTERRUPT(Interrupt51) \
		UNUSED_INTERRUPT(Interrupt52) \
		INTERRUPT(INT3Interrupt) \
		INTERRUPT(INT4Interrupt) \
		UNUSED_INTERRUPT(Interrupt55) \
		UNUSED_INTERRUPT(Interrupt56) \
		UNUSED_INTERRUPT(Interrupt57) \
		UNUSED_INTERRUPT(Interrupt58) \
		UNUSED_INTERRUPT(Interrupt59) \
		UNUSED_INTERRUPT(Interrupt60) \
		UNUSED_INTERRUPT(Interrupt61) \
		INTERRUPT(RTCCInterrupt) \
		UNUSED_INTERRUPT(Interrupt63) \
		UNUSED_INTERRUPT(Interrupt64) \
		INTERRUPT(U1ErrInterrupt) \
		INTERRUPT(U2ErrInterrupt) \
		INTERRUPT(CRCInterrupt) \
		UNUSED_INTERRUPT(Interrupt68) \
		UNUSED_INTERRUPT(Interrupt69) \
		UNUSED_INTERRUPT(Interrupt70) \
		UNUSED_INTERRUPT(Interrupt71) \
		UNUSED_INTERRUPT(Interrupt72) \
		UNUSED_INTERRUPT(Interrupt73) \
		UNUSED_INTERRUPT(Interrupt74) \
		UNUSED_INTERRUPT(Interrupt75) \
		UNUSED_INTERRUPT(Interrupt76) \
		UNUSED_INTERRUPT(Interrupt77) \
		UNUSED_INTERRUPT(Interrupt78) \
		UNUSED_INTERRUPT(Interrupt79) \
		UNUSED_INTERRUPT(Interrupt80) \
		UNUSED_INTERRUPT(Interrupt81) \
		UNUSED_INTERRUPT(Interrupt82) \
		UNUSED_INTERRUPT(Interrupt83) \
		UNUSED_INTERRUPT(Interrupt84) \
		UNUSED_INTERRUPT(Interrupt85) \
		INTERRUPT(USB1Interrupt) \
		UNUSED_INTERRUPT(Interrupt87) \
		UNUSED_INTERRUPT(Interrupt88) \
		UNUSED_INTERRUPT(Interrupt89) \
		UNUSED_INTERRUPT(Interrupt90) \
		UNUSED_INTERRUPT(Interrupt91) \
		UNUSED_INTERRUPT(Interrupt92) \
		UNUSED_INTERRUPT(Interrupt93) \
		UNUSED_INTERRUPT(Interrupt94) \
		UNUSED_INTERRUPT(Interrupt95) \
		UNUSED_INTERRUPT(Interrupt96) \
		UNUSED_INTERRUPT(Interrupt97) \
		UNUSED_INTERRUPT(Interrupt98) \
		UNUSED_INTERRUPT(Interrupt99) \
		UNUSED_INTERRUPT(Interrupt100) \
		UNUSED_INTERRUPT(Interrupt101) \
		UNUSED_INTERRUPT(Interrupt102) \
		UNUSED_INTERRUPT(Interrupt103) \
		UNUSED_INTERRUPT(Interrupt104) \
		UNUSED_INTERRUPT(Interrupt105) \
		UNUSED_INTERRUPT(Interrupt106) \
		UNUSED_INTERRUPT(Interrupt107) \
		UNUSED_INTERRUPT(Interrupt108) \
		UNUSED_INTERRUPT(Interrupt109) \
		UNUSED_INTERRUPT(Interrupt110) \
		UNUSED_INTERRUPT(Interrupt111) \
		UNUSED_INTERRUPT(Interrupt112) \
		UNUSED_INTERRUPT(Interrupt113) \
		UNUSED_INTERRUPT(Interrupt114) \
		UNUSED_INTERRUPT(Interrupt115) \
		UNUSED_INTERRUPT(Interrupt116) \
		UNUSED_INTERRUPT(Interrupt117) \
		/* End macro (the comment gives it a last line without a \) */


SECTIONS {
#ifdef BOOTLOADER
	/* The reset instruction. This creates a jump to the __reset label
	 *  in the C startup code */
	.reset RESET_BASE : {
		LONG(0x040000 | ABSOLUTE(__reset) & 0xffff);
		LONG((ABSOLUTE(__reset) >> 16) & 0x7f);
	} >reset
#endif

	/* Reserve 0x50 bytes of RAM for the debugger if __ICD2RAM is
	 * defined.  It turns out this RAM block is used for all Microchip
	 * debuggers, not just the ICD2.  */
	.icd DATA_BASE : {
		. += (DEFINED(__ICD2RAM) ? 0x50 : 0);
	} >data


#define DEBUG_INFO(X) X 0 : { *(X) }

	DEBUG_INFO(.comment)
	.debug_info 0: { *(.debug_info) *(.gnu.linkonce.wi.*) }
	DEBUG_INFO(.debug_abbrev)
	DEBUG_INFO(.debug_line)
	DEBUG_INFO(.debug_frame)
	DEBUG_INFO(.debug_str)
	DEBUG_INFO(.debug_loc)
	DEBUG_INFO(.debug_macinfo)
	DEBUG_INFO(.debug_pubnames)
	DEBUG_INFO(.debug_ranges)
	DEBUG_INFO(.debug_aranges)



#define CONFIG(X) __##X : { KEEP (*(__##X.sec*)) } > X

	CONFIG(CONFIG1)
	CONFIG(CONFIG2)
	CONFIG(CONFIG3)
	CONFIG(CONFIG4)

#ifdef BOOTLOADER
/* This macro reserves space for each entry in the interrupt map. Its
   job is to create a _ADDR variable for the address where the GOTO
   instruction for each interrupt function will go. Only
   implemented interrupts are mapped. The application will put the
   actual mappings in this space, but the bootloader needs to know
   where each one is so it can put the correct addresses in the IVT. */
#define INTERRUPT(X) X##_ADDR = .; . += 4;
#define UNUSED_INTERRUPT(X)

	.ivt_map IVT_MAP_BASE : {
		. += 4; /* This is where the reset/start instruction will go. */
		INTERRUPT_LIST()
	} >ivt_map
#endif

#undef INTERRUPT
#undef UNUSED_INTERRUPT

#ifdef BOOTLOADER
/* This macro is the interrupt handler addresses that go into the IVT.
   Point the interrupt handler addresses to the addresses in the
   interrupt map, created above. Only acutal implemented interrupts
   (implemented at the platform level) are mapped. */
#define INTERRUPT(X) LONG(DEFINED(X##_ADDR)? ABSOLUTE(X##_ADDR): ABSOLUTE(__DefaultInterrupt));
#define UNUSED_INTERRUPT(X) LONG(ABSOLUTE(__DefaultInterrupt));

	.intvec IVT_BASE : {
		INTERRUPT_LIST()
	} >ivt

#undef INTERRUPT
#undef UNUSED_INTERRUPT


/* Altertate Interrupt Table (ALT IVT) */
#define INTERRUPT(X) ALTHANDLER(X)
#define UNUSED_INTERRUPT(X) ALTHANDLER(X)

	.altintvec ALT_IVT_BASE : {
		INTERRUPT_LIST()
	} >aivt
#endif /* BOOTLOADER */

#undef INTERRUPT
#undef UNUSED_INTERRUPT



#ifdef BOOTLOADER_APP
/* This macro is the Interrupt MAP. The application puts a GOTO
   instruction in each space in the map which jumps to the interrupt
   handler in the application. Note that it takes four words (8 bytes) for each
   goto instruction which is longer than what is stored in the IVT
   which is just the address (and not a GOTO instruction). The first
   slot is special and has a GOTO to the __reset function in libc. This
   way the bootloader just jumps to the beginning of the interrupt map
   to start the application */
#define INTERRUPT(X) LONG(DEFINED(__##X)? (0x040000 | ABSOLUTE(__##X)) : 0x040000 | ABSOLUTE(__DefaultInterrupt)); \
                     LONG(DEFINED(__##X)? (ABSOLUTE(__##X) >> 16) & 0x7f : (ABSOLUTE(__DefaultInterrupt) >> 16) & 0x7f);
#define UNUSED_INTERRUPT(X)

	.ivt_map IVT_MAP_BASE : {
		LONG(0x040000 | ABSOLUTE(__reset) & 0xffff);
		LONG((ABSOLUTE(__reset) >> 16) & 0x7f);
		INTERRUPT_LIST()
	} >ivt_map

#undef INTERRUPT
#undef UNUSED_INTERRUPT

#endif
}

WREG0 = 0x0000;
_WREG0 = 0x0000;
_WREG0bits = 0x0000;
WREG1 = 0x0002;
_WREG1 = 0x0002;
_WREG1bits = 0x0002;
WREG2 = 0x0004;
_WREG2 = 0x0004;
_WREG2bits = 0x0004;
WREG3 = 0x0006;
_WREG3 = 0x0006;
_WREG3bits = 0x0006;
WREG4 = 0x0008;
_WREG4 = 0x0008;
_WREG4bits = 0x0008;
WREG5 = 0x000A;
_WREG5 = 0x000A;
_WREG5bits = 0x000A;
WREG6 = 0x000C;
_WREG6 = 0x000C;
_WREG6bits = 0x000C;
WREG7 = 0x000E;
_WREG7 = 0x000E;
_WREG7bits = 0x000E;
WREG8 = 0x0010;
_WREG8 = 0x0010;
_WREG8bits = 0x0010;
WREG9 = 0x0012;
_WREG9 = 0x0012;
_WREG9bits = 0x0012;
WREG10 = 0x0014;
_WREG10 = 0x0014;
_WREG10bits = 0x0014;
WREG11 = 0x0016;
_WREG11 = 0x0016;
_WREG11bits = 0x0016;
WREG12 = 0x0018;
_WREG12 = 0x0018;
_WREG12bits = 0x0018;
WREG13 = 0x001A;
_WREG13 = 0x001A;
_WREG13bits = 0x001A;
WREG14 = 0x001C;
_WREG14 = 0x001C;
_WREG14bits = 0x001C;
WREG15 = 0x001E;
_WREG15 = 0x001E;
_WREG15bits = 0x001E;
SPLIM = 0x0020;
_SPLIM = 0x0020;
_SPLIMbits = 0x0020;
PCL = 0x002E;
_PCL = 0x002E;
_PCLbits = 0x002E;
PCH = 0x0030;
_PCH = 0x0030;
_PCHbits = 0x0030;
TBLPAG = 0x0032;
_TBLPAG = 0x0032;
_TBLPAGbits = 0x0032;
PSVPAG = 0x0034;
_PSVPAG = 0x0034;
_PSVPAGbits = 0x0034;
RCOUNT = 0x0036;
_RCOUNT = 0x0036;
_RCOUNTbits = 0x0036;
SR = 0x0042;
_SR = 0x0042;
_SRbits = 0x0042;
CORCON = 0x0044;
_CORCON = 0x0044;
_CORCONbits = 0x0044;
DISICNT = 0x0052;
_DISICNT = 0x0052;
_DISICNTbits = 0x0052;
CNEN1 = 0x0060;
_CNEN1 = 0x0060;
_CNEN1bits = 0x0060;
CNEN2 = 0x0062;
_CNEN2 = 0x0062;
_CNEN2bits = 0x0062;
CNPU1 = 0x0068;
_CNPU1 = 0x0068;
_CNPU1bits = 0x0068;
CNPU2 = 0x006A;
_CNPU2 = 0x006A;
_CNPU2bits = 0x006A;
INTCON1 = 0x0080;
_INTCON1 = 0x0080;
_INTCON1bits = 0x0080;
INTCON2 = 0x0082;
_INTCON2 = 0x0082;
_INTCON2bits = 0x0082;
IFS0 = 0x0084;
_IFS0 = 0x0084;
_IFS0bits = 0x0084;
IFS1 = 0x0086;
_IFS1 = 0x0086;
_IFS1bits = 0x0086;
IFS2 = 0x0088;
_IFS2 = 0x0088;
_IFS2bits = 0x0088;
IFS3 = 0x008A;
_IFS3 = 0x008A;
_IFS3bits = 0x008A;
IFS4 = 0x008C;
_IFS4 = 0x008C;
_IFS4bits = 0x008C;
IFS5 = 0x008E;
_IFS5 = 0x008E;
_IFS5bits = 0x008E;
IEC0 = 0x0094;
_IEC0 = 0x0094;
_IEC0bits = 0x0094;
IEC1 = 0x0096;
_IEC1 = 0x0096;
_IEC1bits = 0x0096;
IEC2 = 0x0098;
_IEC2 = 0x0098;
_IEC2bits = 0x0098;
IEC3 = 0x009A;
_IEC3 = 0x009A;
_IEC3bits = 0x009A;
IEC4 = 0x009C;
_IEC4 = 0x009C;
_IEC4bits = 0x009C;
IEC5 = 0x009E;
_IEC5 = 0x009E;
_IEC5bits = 0x009E;
IPC0 = 0x00A4;
_IPC0 = 0x00A4;
_IPC0bits = 0x00A4;
IPC1 = 0x00A6;
_IPC1 = 0x00A6;
_IPC1bits = 0x00A6;
IPC2 = 0x00A8;
_IPC2 = 0x00A8;
_IPC2bits = 0x00A8;
IPC3 = 0x00AA;
_IPC3 = 0x00AA;
_IPC3bits = 0x00AA;
IPC4 = 0x00AC;
_IPC4 = 0x00AC;
_IPC4bits = 0x00AC;
IPC5 = 0x00AE;
_IPC5 = 0x00AE;
_IPC5bits = 0x00AE;
IPC6 = 0x00B0;
_IPC6 = 0x00B0;
_IPC6bits = 0x00B0;
IPC7 = 0x00B2;
_IPC7 = 0x00B2;
_IPC7bits = 0x00B2;
IPC8 = 0x00B4;
_IPC8 = 0x00B4;
_IPC8bits = 0x00B4;
IPC9 = 0x00B6;
_IPC9 = 0x00B6;
_IPC9bits = 0x00B6;
IPC10 = 0x00B8;
_IPC10 = 0x00B8;
_IPC10bits = 0x00B8;
IPC11 = 0x00BA;
_IPC11 = 0x00BA;
_IPC11bits = 0x00BA;
IPC12 = 0x00BC;
_IPC12 = 0x00BC;
_IPC12bits = 0x00BC;
IPC15 = 0x00C2;
_IPC15 = 0x00C2;
_IPC15bits = 0x00C2;
IPC16 = 0x00C4;
_IPC16 = 0x00C4;
_IPC16bits = 0x00C4;
IPC18 = 0x00C8;
_IPC18 = 0x00C8;
_IPC18bits = 0x00C8;
IPC19 = 0x00CA;
_IPC19 = 0x00CA;
_IPC19bits = 0x00CA;
IPC21 = 0x00CE;
_IPC21 = 0x00CE;
_IPC21bits = 0x00CE;
INTTREG = 0x00E0;
_INTTREG = 0x00E0;
_INTTREGbits = 0x00E0;
TMR1 = 0x0100;
_TMR1 = 0x0100;
_TMR1bits = 0x0100;
PR1 = 0x0102;
_PR1 = 0x0102;
_PR1bits = 0x0102;
T1CON = 0x0104;
_T1CON = 0x0104;
_T1CONbits = 0x0104;
TMR2 = 0x0106;
_TMR2 = 0x0106;
_TMR2bits = 0x0106;
TMR3HLD = 0x0108;
_TMR3HLD = 0x0108;
_TMR3HLDbits = 0x0108;
TMR3 = 0x010A;
_TMR3 = 0x010A;
_TMR3bits = 0x010A;
PR2 = 0x010C;
_PR2 = 0x010C;
_PR2bits = 0x010C;
PR3 = 0x010E;
_PR3 = 0x010E;
_PR3bits = 0x010E;
T2CON = 0x0110;
_T2CON = 0x0110;
_T2CONbits = 0x0110;
T3CON = 0x0112;
_T3CON = 0x0112;
_T3CONbits = 0x0112;
TMR4 = 0x0114;
_TMR4 = 0x0114;
_TMR4bits = 0x0114;
TMR5HLD = 0x0116;
_TMR5HLD = 0x0116;
_TMR5HLDbits = 0x0116;
TMR5 = 0x0118;
_TMR5 = 0x0118;
_TMR5bits = 0x0118;
PR4 = 0x011A;
_PR4 = 0x011A;
_PR4bits = 0x011A;
PR5 = 0x011C;
_PR5 = 0x011C;
_PR5bits = 0x011C;
T4CON = 0x011E;
_T4CON = 0x011E;
_T4CONbits = 0x011E;
T5CON = 0x0120;
_T5CON = 0x0120;
_T5CONbits = 0x0120;
IC1CON1 = 0x0140;
_IC1CON1 = 0x0140;
_IC1CON1bits = 0x0140;
IC1CON2 = 0x0142;
_IC1CON2 = 0x0142;
_IC1CON2bits = 0x0142;
IC1BUF = 0x0144;
_IC1BUF = 0x0144;
_IC1BUFbits = 0x0144;
IC1TMR = 0x0146;
_IC1TMR = 0x0146;
_IC1TMRbits = 0x0146;
IC2CON1 = 0x0148;
_IC2CON1 = 0x0148;
_IC2CON1bits = 0x0148;
IC2CON2 = 0x014A;
_IC2CON2 = 0x014A;
_IC2CON2bits = 0x014A;
IC2BUF = 0x014C;
_IC2BUF = 0x014C;
_IC2BUFbits = 0x014C;
IC2TMR = 0x014E;
_IC2TMR = 0x014E;
_IC2TMRbits = 0x014E;
IC3CON1 = 0x0150;
_IC3CON1 = 0x0150;
_IC3CON1bits = 0x0150;
IC3CON2 = 0x0152;
_IC3CON2 = 0x0152;
_IC3CON2bits = 0x0152;
IC3BUF = 0x0154;
_IC3BUF = 0x0154;
_IC3BUFbits = 0x0154;
IC3TMR = 0x0156;
_IC3TMR = 0x0156;
_IC3TMRbits = 0x0156;
IC4CON1 = 0x0158;
_IC4CON1 = 0x0158;
_IC4CON1bits = 0x0158;
IC4CON2 = 0x015A;
_IC4CON2 = 0x015A;
_IC4CON2bits = 0x015A;
IC4BUF = 0x015C;
_IC4BUF = 0x015C;
_IC4BUFbits = 0x015C;
IC4TMR = 0x015E;
_IC4TMR = 0x015E;
_IC4TMRbits = 0x015E;
IC5CON1 = 0x0160;
_IC5CON1 = 0x0160;
_IC5CON1bits = 0x0160;
IC5CON2 = 0x0162;
_IC5CON2 = 0x0162;
_IC5CON2bits = 0x0162;
IC5BUF = 0x0164;
_IC5BUF = 0x0164;
_IC5BUFbits = 0x0164;
IC5TMR = 0x0166;
_IC5TMR = 0x0166;
_IC5TMRbits = 0x0166;
OC1CON1 = 0x0190;
_OC1CON1 = 0x0190;
_OC1CON1bits = 0x0190;
OC1CON2 = 0x0192;
_OC1CON2 = 0x0192;
_OC1CON2bits = 0x0192;
OC1RS = 0x0194;
_OC1RS = 0x0194;
_OC1RSbits = 0x0194;
OC1R = 0x0196;
_OC1R = 0x0196;
_OC1Rbits = 0x0196;
OC1TMR = 0x0198;
_OC1TMR = 0x0198;
_OC1TMRbits = 0x0198;
OC2CON1 = 0x019A;
_OC2CON1 = 0x019A;
_OC2CON1bits = 0x019A;
OC2CON2 = 0x019C;
_OC2CON2 = 0x019C;
_OC2CON2bits = 0x019C;
OC2RS = 0x019E;
_OC2RS = 0x019E;
_OC2RSbits = 0x019E;
OC2R = 0x01A0;
_OC2R = 0x01A0;
_OC2Rbits = 0x01A0;
OC2TMR = 0x01A2;
_OC2TMR = 0x01A2;
_OC2TMRbits = 0x01A2;
OC3CON1 = 0x01A4;
_OC3CON1 = 0x01A4;
_OC3CON1bits = 0x01A4;
OC3CON2 = 0x01A6;
_OC3CON2 = 0x01A6;
_OC3CON2bits = 0x01A6;
OC3RS = 0x01A8;
_OC3RS = 0x01A8;
_OC3RSbits = 0x01A8;
OC3R = 0x01AA;
_OC3R = 0x01AA;
_OC3Rbits = 0x01AA;
OC3TMR = 0x01AC;
_OC3TMR = 0x01AC;
_OC3TMRbits = 0x01AC;
OC4CON1 = 0x01AE;
_OC4CON1 = 0x01AE;
_OC4CON1bits = 0x01AE;
OC4CON2 = 0x01B0;
_OC4CON2 = 0x01B0;
_OC4CON2bits = 0x01B0;
OC4RS = 0x01B2;
_OC4RS = 0x01B2;
_OC4RSbits = 0x01B2;
OC4R = 0x01B4;
_OC4R = 0x01B4;
_OC4Rbits = 0x01B4;
OC4TMR = 0x01B6;
_OC4TMR = 0x01B6;
_OC4TMRbits = 0x01B6;
OC5CON1 = 0x01B8;
_OC5CON1 = 0x01B8;
_OC5CON1bits = 0x01B8;
OC5CON2 = 0x01BA;
_OC5CON2 = 0x01BA;
_OC5CON2bits = 0x01BA;
OC5RS = 0x01BC;
_OC5RS = 0x01BC;
_OC5RSbits = 0x01BC;
OC5R = 0x01BE;
_OC5R = 0x01BE;
_OC5Rbits = 0x01BE;
OC5TMR = 0x01C0;
_OC5TMR = 0x01C0;
_OC5TMRbits = 0x01C0;
I2C1RCV = 0x0200;
_I2C1RCV = 0x0200;
_I2C1RCVbits = 0x0200;
I2C1TRN = 0x0202;
_I2C1TRN = 0x0202;
_I2C1TRNbits = 0x0202;
I2C1BRG = 0x0204;
_I2C1BRG = 0x0204;
_I2C1BRGbits = 0x0204;
I2C1CON = 0x0206;
_I2C1CON = 0x0206;
_I2C1CONbits = 0x0206;
I2C1STAT = 0x0208;
_I2C1STAT = 0x0208;
_I2C1STATbits = 0x0208;
I2C1ADD = 0x020A;
_I2C1ADD = 0x020A;
_I2C1ADDbits = 0x020A;
I2C1MSK = 0x020C;
_I2C1MSK = 0x020C;
_I2C1MSKbits = 0x020C;
I2C2RCV = 0x0210;
_I2C2RCV = 0x0210;
_I2C2RCVbits = 0x0210;
I2C2TRN = 0x0212;
_I2C2TRN = 0x0212;
_I2C2TRNbits = 0x0212;
I2C2BRG = 0x0214;
_I2C2BRG = 0x0214;
_I2C2BRGbits = 0x0214;
I2C2CON = 0x0216;
_I2C2CON = 0x0216;
_I2C2CONbits = 0x0216;
I2C2STAT = 0x0218;
_I2C2STAT = 0x0218;
_I2C2STATbits = 0x0218;
I2C2ADD = 0x021A;
_I2C2ADD = 0x021A;
_I2C2ADDbits = 0x021A;
I2C2MSK = 0x021C;
_I2C2MSK = 0x021C;
_I2C2MSKbits = 0x021C;
U1MODE = 0x0220;
_U1MODE = 0x0220;
_U1MODEbits = 0x0220;
U1STA = 0x0222;
_U1STA = 0x0222;
_U1STAbits = 0x0222;
U1TXREG = 0x0224;
_U1TXREG = 0x0224;
_U1TXREGbits = 0x0224;
U1RXREG = 0x0226;
_U1RXREG = 0x0226;
_U1RXREGbits = 0x0226;
U1BRG = 0x0228;
_U1BRG = 0x0228;
_U1BRGbits = 0x0228;
U2MODE = 0x0230;
_U2MODE = 0x0230;
_U2MODEbits = 0x0230;
U2STA = 0x0232;
_U2STA = 0x0232;
_U2STAbits = 0x0232;
U2TXREG = 0x0234;
_U2TXREG = 0x0234;
_U2TXREGbits = 0x0234;
U2RXREG = 0x0236;
_U2RXREG = 0x0236;
_U2RXREGbits = 0x0236;
U2BRG = 0x0238;
_U2BRG = 0x0238;
_U2BRGbits = 0x0238;
SPI1STAT = 0x0240;
_SPI1STAT = 0x0240;
_SPI1STATbits = 0x0240;
SPI1CON1 = 0x0242;
_SPI1CON1 = 0x0242;
_SPI1CON1bits = 0x0242;
SPI1CON2 = 0x0244;
_SPI1CON2 = 0x0244;
_SPI1CON2bits = 0x0244;
SPI1BUF = 0x0248;
_SPI1BUF = 0x0248;
_SPI1BUFbits = 0x0248;
SPI2STAT = 0x0260;
_SPI2STAT = 0x0260;
_SPI2STATbits = 0x0260;
SPI2CON1 = 0x0262;
_SPI2CON1 = 0x0262;
_SPI2CON1bits = 0x0262;
SPI2CON2 = 0x0264;
_SPI2CON2 = 0x0264;
_SPI2CON2bits = 0x0264;
SPI2BUF = 0x0268;
_SPI2BUF = 0x0268;
_SPI2BUFbits = 0x0268;
TRISA = 0x02C0;
_TRISA = 0x02C0;
_TRISAbits = 0x02C0;
PORTA = 0x02C2;
_PORTA = 0x02C2;
_PORTAbits = 0x02C2;
LATA = 0x02C4;
_LATA = 0x02C4;
_LATAbits = 0x02C4;
ODCA = 0x02C6;
_ODCA = 0x02C6;
_ODCAbits = 0x02C6;
TRISB = 0x02C8;
_TRISB = 0x02C8;
_TRISBbits = 0x02C8;
PORTB = 0x02CA;
_PORTB = 0x02CA;
_PORTBbits = 0x02CA;
LATB = 0x02CC;
_LATB = 0x02CC;
_LATBbits = 0x02CC;
ODCB = 0x02CE;
_ODCB = 0x02CE;
_ODCBbits = 0x02CE;
TRISC = 0x02D0;
_TRISC = 0x02D0;
_TRISCbits = 0x02D0;
PORTC = 0x02D2;
_PORTC = 0x02D2;
_PORTCbits = 0x02D2;
LATC = 0x02D4;
_LATC = 0x02D4;
_LATCbits = 0x02D4;
ODCC = 0x02D6;
_ODCC = 0x02D6;
_ODCCbits = 0x02D6;
PADCFG1 = 0x02FC;
_PADCFG1 = 0x02FC;
_PADCFG1bits = 0x02FC;
ADC1BUF0 = 0x0300;
_ADC1BUF0 = 0x0300;
_ADC1BUF0bits = 0x0300;
ADC1BUF1 = 0x0302;
_ADC1BUF1 = 0x0302;
_ADC1BUF1bits = 0x0302;
ADC1BUF2 = 0x0304;
_ADC1BUF2 = 0x0304;
_ADC1BUF2bits = 0x0304;
ADC1BUF3 = 0x0306;
_ADC1BUF3 = 0x0306;
_ADC1BUF3bits = 0x0306;
ADC1BUF4 = 0x0308;
_ADC1BUF4 = 0x0308;
_ADC1BUF4bits = 0x0308;
ADC1BUF5 = 0x030A;
_ADC1BUF5 = 0x030A;
_ADC1BUF5bits = 0x030A;
ADC1BUF6 = 0x030C;
_ADC1BUF6 = 0x030C;
_ADC1BUF6bits = 0x030C;
ADC1BUF7 = 0x030E;
_ADC1BUF7 = 0x030E;
_ADC1BUF7bits = 0x030E;
ADC1BUF8 = 0x0310;
_ADC1BUF8 = 0x0310;
_ADC1BUF8bits = 0x0310;
ADC1BUF9 = 0x0312;
_ADC1BUF9 = 0x0312;
_ADC1BUF9bits = 0x0312;
ADC1BUFA = 0x0314;
_ADC1BUFA = 0x0314;
_ADC1BUFAbits = 0x0314;
ADC1BUFB = 0x0316;
_ADC1BUFB = 0x0316;
_ADC1BUFBbits = 0x0316;
ADC1BUFC = 0x0318;
_ADC1BUFC = 0x0318;
_ADC1BUFCbits = 0x0318;
ADC1BUFD = 0x031A;
_ADC1BUFD = 0x031A;
_ADC1BUFDbits = 0x031A;
ADC1BUFE = 0x031C;
_ADC1BUFE = 0x031C;
_ADC1BUFEbits = 0x031C;
ADC1BUFF = 0x031E;
_ADC1BUFF = 0x031E;
_ADC1BUFFbits = 0x031E;
AD1CON1 = 0x0320;
_AD1CON1 = 0x0320;
_AD1CON1bits = 0x0320;
AD1CON2 = 0x0322;
_AD1CON2 = 0x0322;
_AD1CON2bits = 0x0322;
AD1CON3 = 0x0324;
_AD1CON3 = 0x0324;
_AD1CON3bits = 0x0324;
AD1CHS = 0x0328;
_AD1CHS = 0x0328;
_AD1CHSbits = 0x0328;
AD1PCFG = 0x032C;
_AD1PCFG = 0x032C;
_AD1PCFGbits = 0x032C;
AD1CSSL = 0x0330;
_AD1CSSL = 0x0330;
_AD1CSSLbits = 0x0330;
CTMUCON = 0x033C;
_CTMUCON = 0x033C;
_CTMUCONbits = 0x033C;
CTMUICON = 0x033E;
_CTMUICON = 0x033E;
_CTMUICONbits = 0x033E;
U1OTGIR = 0x0480;
_U1OTGIR = 0x0480;
_U1OTGIRbits = 0x0480;
U1OTGIE = 0x0482;
_U1OTGIE = 0x0482;
_U1OTGIEbits = 0x0482;
U1OTGSTAT = 0x0484;
_U1OTGSTAT = 0x0484;
_U1OTGSTATbits = 0x0484;
U1OTGCON = 0x0486;
_U1OTGCON = 0x0486;
_U1OTGCONbits = 0x0486;
U1PWRC = 0x0488;
_U1PWRC = 0x0488;
_U1PWRCbits = 0x0488;
U1IR = 0x048A;
_U1IR = 0x048A;
_U1IRbits = 0x048A;
U1IE = 0x048C;
_U1IE = 0x048C;
_U1IEbits = 0x048C;
U1EIR = 0x048E;
_U1EIR = 0x048E;
_U1EIRbits = 0x048E;
U1EIE = 0x0490;
_U1EIE = 0x0490;
_U1EIEbits = 0x0490;
U1STAT = 0x0492;
_U1STAT = 0x0492;
_U1STATbits = 0x0492;
U1CON = 0x0494;
_U1CON = 0x0494;
_U1CONbits = 0x0494;
U1ADDR = 0x0496;
_U1ADDR = 0x0496;
_U1ADDRbits = 0x0496;
U1BDTP1 = 0x0498;
_U1BDTP1 = 0x0498;
_U1BDTP1bits = 0x0498;
U1FRML = 0x049A;
_U1FRML = 0x049A;
_U1FRMLbits = 0x049A;
U1FRMH = 0x049C;
_U1FRMH = 0x049C;
_U1FRMHbits = 0x049C;
U1TOK = 0x049E;
_U1TOK = 0x049E;
_U1TOKbits = 0x049E;
U1SOF = 0x04A0;
_U1SOF = 0x04A0;
_U1SOFbits = 0x04A0;
U1CNFG1 = 0x04A6;
_U1CNFG1 = 0x04A6;
_U1CNFG1bits = 0x04A6;
U1CNFG2 = 0x04A8;
_U1CNFG2 = 0x04A8;
_U1CNFG2bits = 0x04A8;
U1EP0 = 0x04AA;
_U1EP0 = 0x04AA;
_U1EP0bits = 0x04AA;
U1EP1 = 0x04AC;
_U1EP1 = 0x04AC;
_U1EP1bits = 0x04AC;
U1EP2 = 0x04AE;
_U1EP2 = 0x04AE;
_U1EP2bits = 0x04AE;
U1EP3 = 0x04B0;
_U1EP3 = 0x04B0;
_U1EP3bits = 0x04B0;
U1EP4 = 0x04B2;
_U1EP4 = 0x04B2;
_U1EP4bits = 0x04B2;
U1EP5 = 0x04B4;
_U1EP5 = 0x04B4;
_U1EP5bits = 0x04B4;
U1EP6 = 0x04B6;
_U1EP6 = 0x04B6;
_U1EP6bits = 0x04B6;
U1EP7 = 0x04B8;
_U1EP7 = 0x04B8;
_U1EP7bits = 0x04B8;
U1EP8 = 0x04BA;
_U1EP8 = 0x04BA;
_U1EP8bits = 0x04BA;
U1EP9 = 0x04BC;
_U1EP9 = 0x04BC;
_U1EP9bits = 0x04BC;
U1EP10 = 0x04BE;
_U1EP10 = 0x04BE;
_U1EP10bits = 0x04BE;
U1EP11 = 0x04C0;
_U1EP11 = 0x04C0;
_U1EP11bits = 0x04C0;
U1EP12 = 0x04C2;
_U1EP12 = 0x04C2;
_U1EP12bits = 0x04C2;
U1EP13 = 0x04C4;
_U1EP13 = 0x04C4;
_U1EP13bits = 0x04C4;
U1EP14 = 0x04C6;
_U1EP14 = 0x04C6;
_U1EP14bits = 0x04C6;
U1EP15 = 0x04C8;
_U1EP15 = 0x04C8;
_U1EP15bits = 0x04C8;
U1PWMRRS = 0x04CC;
_U1PWMRRS = 0x04CC;
_U1PWMRRSbits = 0x04CC;
U1PWMCON = 0x04CE;
_U1PWMCON = 0x04CE;
_U1PWMCONbits = 0x04CE;
PMCON = 0x0600;
_PMCON = 0x0600;
_PMCONbits = 0x0600;
PMMODE = 0x0602;
_PMMODE = 0x0602;
_PMMODEbits = 0x0602;
PMADDR = 0x0604;
_PMADDR = 0x0604;
_PMADDRbits = 0x0604;
PMDOUT1 = 0x0605;
_PMDOUT1 = 0x0605;
_PMDOUT1bits = 0x0605;
PMDOUT2 = 0x0606;
_PMDOUT2 = 0x0606;
_PMDOUT2bits = 0x0606;
PMDIN1 = 0x0608;
_PMDIN1 = 0x0608;
_PMDIN1bits = 0x0608;
PMDIN2 = 0x060A;
_PMDIN2 = 0x060A;
_PMDIN2bits = 0x060A;
PMAEN = 0x060C;
_PMAEN = 0x060C;
_PMAENbits = 0x060C;
PMSTAT = 0x060E;
_PMSTAT = 0x060E;
_PMSTATbits = 0x060E;
ALRMVAL = 0x0620;
_ALRMVAL = 0x0620;
_ALRMVALbits = 0x0620;
ALCFGRPT = 0x0622;
_ALCFGRPT = 0x0622;
_ALCFGRPTbits = 0x0622;
RTCVAL = 0x0624;
_RTCVAL = 0x0624;
_RTCVALbits = 0x0624;
RCFGCAL = 0x0626;
_RCFGCAL = 0x0626;
_RCFGCALbits = 0x0626;
CRCCON1 = 0x0640;
_CRCCON1 = 0x0640;
_CRCCON1bits = 0x0640;
CRCCON2 = 0x0642;
_CRCCON2 = 0x0642;
_CRCCON2bits = 0x0642;
CRCXORL = 0x0644;
_CRCXORL = 0x0644;
_CRCXORLbits = 0x0644;
CRCXORH = 0x0646;
_CRCXORH = 0x0646;
_CRCXORHbits = 0x0646;
CRCDATL = 0x0648;
_CRCDATL = 0x0648;
_CRCDATLbits = 0x0648;
CRCDATH = 0x064A;
_CRCDATH = 0x064A;
_CRCDATHbits = 0x064A;
CRCWDATL = 0x064C;
_CRCWDATL = 0x064C;
_CRCWDATLbits = 0x064C;
CRCWDATH = 0x064E;
_CRCWDATH = 0x064E;
_CRCWDATHbits = 0x064E;
CMSTAT = 0x0650;
_CMSTAT = 0x0650;
_CMSTATbits = 0x0650;
CVRCON = 0x0652;
_CVRCON = 0x0652;
_CVRCONbits = 0x0652;
CM1CON = 0x0654;
_CM1CON = 0x0654;
_CM1CONbits = 0x0654;
CM2CON = 0x065C;
_CM2CON = 0x065C;
_CM2CONbits = 0x065C;
CM3CON = 0x0664;
_CM3CON = 0x0664;
_CM3CONbits = 0x0664;
RPINR0 = 0x0680;
_RPINR0 = 0x0680;
_RPINR0bits = 0x0680;
RPINR1 = 0x0682;
_RPINR1 = 0x0682;
_RPINR1bits = 0x0682;
RPINR3 = 0x0686;
_RPINR3 = 0x0686;
_RPINR3bits = 0x0686;
RPINR4 = 0x0688;
_RPINR4 = 0x0688;
_RPINR4bits = 0x0688;
RPINR7 = 0x068E;
_RPINR7 = 0x068E;
_RPINR7bits = 0x068E;
RPINR8 = 0x0690;
_RPINR8 = 0x0690;
_RPINR8bits = 0x0690;
RPINR9 = 0x0692;
_RPINR9 = 0x0692;
_RPINR9bits = 0x0692;
RPINR11 = 0x0696;
_RPINR11 = 0x0696;
_RPINR11bits = 0x0696;
RPINR18 = 0x06A4;
_RPINR18 = 0x06A4;
_RPINR18bits = 0x06A4;
RPINR19 = 0x06A6;
_RPINR19 = 0x06A6;
_RPINR19bits = 0x06A6;
RPINR20 = 0x06A8;
_RPINR20 = 0x06A8;
_RPINR20bits = 0x06A8;
RPINR21 = 0x06AA;
_RPINR21 = 0x06AA;
_RPINR21bits = 0x06AA;
RPINR22 = 0x06AC;
_RPINR22 = 0x06AC;
_RPINR22bits = 0x06AC;
RPINR23 = 0x06AE;
_RPINR23 = 0x06AE;
_RPINR23bits = 0x06AE;
RPOR0 = 0x06C0;
_RPOR0 = 0x06C0;
_RPOR0bits = 0x06C0;
RPOR1 = 0x06C2;
_RPOR1 = 0x06C2;
_RPOR1bits = 0x06C2;
RPOR2 = 0x06C4;
_RPOR2 = 0x06C4;
_RPOR2bits = 0x06C4;
RPOR3 = 0x06C6;
_RPOR3 = 0x06C6;
_RPOR3bits = 0x06C6;
RPOR4 = 0x06C8;
_RPOR4 = 0x06C8;
_RPOR4bits = 0x06C8;
RPOR5 = 0x06CA;
_RPOR5 = 0x06CA;
_RPOR5bits = 0x06CA;
RPOR6 = 0x06CC;
_RPOR6 = 0x06CC;
_RPOR6bits = 0x06CC;
RPOR7 = 0x06CE;
_RPOR7 = 0x06CE;
_RPOR7bits = 0x06CE;
RPOR8 = 0x06D0;
_RPOR8 = 0x06D0;
_RPOR8bits = 0x06D0;
RPOR9 = 0x06D2;
_RPOR9 = 0x06D2;
_RPOR9bits = 0x06D2;
RPOR10 = 0x06D4;
_RPOR10 = 0x06D4;
_RPOR10bits = 0x06D4;
RPOR11 = 0x06D6;
_RPOR11 = 0x06D6;
_RPOR11bits = 0x06D6;
RPOR12 = 0x06D8;
_RPOR12 = 0x06D8;
_RPOR12bits = 0x06D8;
RCON = 0x0740;
_RCON = 0x0740;
_RCONbits = 0x0740;
OSCCON = 0x0742;
_OSCCON = 0x0742;
_OSCCONbits = 0x0742;
CLKDIV = 0x0744;
_CLKDIV = 0x0744;
_CLKDIVbits = 0x0744;
OSCTUN = 0x0748;
_OSCTUN = 0x0748;
_OSCTUNbits = 0x0748;
REFOCON = 0x074E;
_REFOCON = 0x074E;
_REFOCONbits = 0x074E;
DSCON = 0x758;
_DSCON = 0x758;
_DSCONbits = 0x758;
DSWAKE = 0x075A;
_DSWAKE = 0x075A;
_DSWAKEbits = 0x075A;
DSGPR0 = 0x075C;
_DSGPR0 = 0x075C;
_DSGPR0bits = 0x075C;
DSGPR1 = 0x075E;
_DSGPR1 = 0x075E;
_DSGPR1bits = 0x075E;
NVMCON = 0x0760;
_NVMCON = 0x0760;
_NVMCONbits = 0x0760;
NVMKEY = 0x0766;
_NVMKEY = 0x0766;
_NVMKEYbits = 0x0766;
PMD1 = 0x0770;
_PMD1 = 0x0770;
_PMD1bits = 0x0770;
PMD2 = 0x0772;
_PMD2 = 0x0772;
_PMD2bits = 0x0772;
PMD3 = 0x0774;
_PMD3 = 0x0774;
_PMD3bits = 0x0774;
PMD4 = 0x0776;
_PMD4 = 0x0776;
_PMD4bits = 0x0776;

